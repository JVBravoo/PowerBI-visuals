<#@ template language="C#" debug="true" inherits="XidlGenerator" hostSpecific="true" #>
<#@ output extension=".xml" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ Assembly name="Microsoft.Bond.Rules.dll" #>
<#@ import namespace="Microsoft.AdCenter.Cyprus.XIDL" #>

<#@ parameter name="ProjectType" Processor="ParameterProcessor" type="System.String" required="false" BaseClassProp="true"#>
<#@ parameter name="ProjectName" Processor="ParameterProcessor" type="System.String" required="true" BaseClassProp="true"#>
<#

base.AddRules(
    new XmlDocs(ProjectName)
);

base.Generate();
#>
<#+
public class XmlDocs
    : Microsoft.AdCenter.Cyprus.XIDL.XidlDataRule
{
    public XmlDocs(string projectName)
    {
        OutputFileName = String.Format("{0}.xml", projectName);
        
        AddRules(new Xml_Namespace());
    }

    public override void FileBegin(CyprusData o)
    {
        StandardFileHeader header = new StandardFileHeader();
        header.OutputHeader(Options, OutputFileName);
        Utils.InitAllTypes(o.AllParserTypes());
#>
<?xml-stylesheet type="text/xsl" href="..\eventXSLT.xsl"?>
<Documentation>
<#+
    }
        public override void FileEnd(TypeBase o)
        {
#>
</Documentation>
<#+
        }

        public override void FileEnd(CyprusData o)
        {
#>
</Documentation>
<#+
        }
}

public class CustomIdlTypeMapping
    : TypeNameMapping
{
    public CustomIdlTypeMapping()
    {
        BoolType = "boolean";
        Int8Type = "number";
        Int16Type = "number";
        Int32Type = "number";
        Int64Type = "number";
        UInt8Type = "number";
        UInt16Type = "number";
        UInt32Type = "number";
        UInt64Type = "number";
        FloatType = "number";
        DoubleType = "number";
        DateTimeType = "Date";
        TimeSpanType = "number";
        GuidType = "string";
        EnumType = null;
        StringType = "string";
        String16Type = "string";
        MetaType = "bond_meta::{0}";
        ListType = "vector<{0}>";
        LinkedListType = "list<{0}>";
        SetType = "set<{0}>";
        MapType = "map<{0}, {1}>";
        NullableType = "nullable<{0}>";
        NullableStructType = "nullable<{0}>";
        BlobType = "blob";
        BondedType = "bonded<{0}>";
        MaybeType = "{0}";
        GlobalScopePrefix = "";
        NamespaceSeparator = ".";
    }
}

#>
<#+
internal class Xml_Namespace
        : XidlNamespaceRule
{
    public Xml_Namespace()
    {
        AddRules(new Xml_Class_Begin());
        AddRules(new Xml_Class_Constructor());
        AddRules(new Xml_Class_End());
    }

    public override void NamespaceBegin(Namespace o)
    {
    }

    public override void NamespaceEnd(Namespace o)
    {
    }
}
#>
<#+ 
public class StandardFileHeader
	: SubTemplate
{
	
	public void OutputHeader(CodeGenOptions options, string fileName)
	{
		string toolName = options.ToolName;
		string toolVer = string.Format("{0}.{1}.{2}", options.ToolVersion.Major, options.ToolVersion.Minor, options.ToolVersion.Build);
		string toolInfoStr = string.Empty;
		if (options.ToolInfo != string.Empty)
		{
			toolInfoStr = ", Build="+options.ToolInfo;
		}
#>
<#+
	}
}
#>
<#+
internal class Utils
{
    static Utils()
    {
        m_bondTypeConstMap = new System.Collections.Generic.Dictionary<Type, string>();
        m_bondTypeConstMap[typeof(String8Field)] = BondTypeConstNamespace + "BT_STRING";
        m_bondTypeConstMap[typeof(String16Field)] = BondTypeConstNamespace + "BT_WSTRING";
        m_bondTypeConstMap[typeof(BoolField)] = BondTypeConstNamespace + "BT_BOOL";
        m_bondTypeConstMap[typeof(UInt8Field)] = BondTypeConstNamespace + "BT_UINT8";
        m_bondTypeConstMap[typeof(UInt16Field)] = BondTypeConstNamespace + "BT_UINT16";
        m_bondTypeConstMap[typeof(UInt32Field)] = BondTypeConstNamespace + "BT_UINT32";
        m_bondTypeConstMap[typeof(UInt64Field)] = BondTypeConstNamespace + "BT_UINT64";
        m_bondTypeConstMap[typeof(Int8Field)] = BondTypeConstNamespace + "BT_INT8";
        m_bondTypeConstMap[typeof(Int16Field)] = BondTypeConstNamespace + "BT_INT16";
        m_bondTypeConstMap[typeof(Int32Field)] = BondTypeConstNamespace + "BT_INT32";
        m_bondTypeConstMap[typeof(Int64Field)] = BondTypeConstNamespace + "BT_INT64";
        m_bondTypeConstMap[typeof(FloatField)] = BondTypeConstNamespace + "BT_FLOAT";
        m_bondTypeConstMap[typeof(DoubleField)] = BondTypeConstNamespace + "BT_DOUBLE";
        m_bondTypeConstMap[typeof(ListField)] = BondTypeConstNamespace + "BT_LIST";
        m_bondTypeConstMap[typeof(LinkedListField)] = BondTypeConstNamespace + "BT_LIST";
        m_bondTypeConstMap[typeof(SetField)] = BondTypeConstNamespace + "BT_SET";
        m_bondTypeConstMap[typeof(MapField)] = BondTypeConstNamespace + "BT_MAP";
        m_bondTypeConstMap[typeof(RefStructField)] = BondTypeConstNamespace + "BT_STRUCT";
        m_bondTypeConstMap[typeof(NullableField)] = BondTypeConstNamespace + "BT_LIST";
        m_bondTypeConstMap[typeof(EnumField)] = BondTypeConstNamespace + "BT_INT32";
        m_bondTypeConstMap[typeof(BlobField)] = BondTypeConstNamespace + "BT_LIST";
        m_bondTypeConstMap[typeof(BondedField)] = BondTypeConstNamespace + "BT_STRUCT";
        
        //TODO: support more field types.
    }
    
    public static string ListAttributesAsComment(IEnumerable<CustomAttribute> attributes)
    {
        if (attributes == null)
        {
            return "";
        }

        StringBuilder sb = new StringBuilder();
        foreach (CustomAttribute attr in attributes)
        {
            sb.AppendLine(string.Format("// [{0}({1})]", attr.Name, attr.Value));
        }
        return sb.ToString().TrimEnd();
    }
    
    public static string GetBondTypeConst(FieldBase field)
    {
        Type type = field.GetType();
        if (m_bondTypeConstMap.ContainsKey(type))
        {
            return m_bondTypeConstMap[type];
        }
        else
        {
            return BondTypeConstNamespace + "BT_UNAVAILABLE";
        }
    }

    /// Basically, same as structDef.Name, but is template-aware,
    /// so adds template params to the name.
    public static string ConstructClassName(StructDef structDef)
    {
        string templateArgs = string.Empty;
        if (structDef.TypeParams != null)
        {
            foreach (string templType in structDef.TypeParams)
            {
                if (templateArgs.Length != 0)
                {
                    templateArgs += ", ";
                }
                templateArgs += templType;
            }
            templateArgs = "<" + templateArgs + ">";
        }
        return structDef.Name + templateArgs;
    }

    public static string ModifierToIdl(FieldBase field)
    {
        switch(field.Modifier)
        {
            case FieldModifier.Optional:
                if (field is MetaField)
                {
                    return "required_optional";
                }
                else
                {
                    return "optional";
                }

            case FieldModifier.Required:
                return "required_field";

            case FieldModifier.RequiredOptional:
                return "required_optional";
        }
        throw new Exception("Unknown value for FieldModifier: "+field.Modifier);
    }

    public static string GetUniqueVariableName()
    {
        return string.Format("i{0}", m_uid++);
    }

    public static string GetDefaultValueString(FieldBase field)
    {
        string defaultString = "";
        if (field is ListField || field is LinkedListField || field is BlobField)
        {
            defaultString = "[]";
        }
        else if (field is SetField || field is MapField ||
                 field is RefStructField || field is BondedField
                )
        {
            defaultString = string.Format("new {0}()", field.GetFieldType());
        }
        else if (field is Int64Field || field is UInt64Field)
        {
            defaultString = string.Format("new {0}(\"{1}\")", field.GetFieldType(), field.DefaultAsString);
        }
        else if (field is EnumField)
        {
            EnumField o = (EnumField)field;
            if (!o.IsNothing && !string.IsNullOrEmpty(o.Default))
            {
                defaultString = string.Format(
                    "{0}.{1}",
                    o.GetFieldType(),
                    o.Default
                    );
            }
        }
        else if (!string.IsNullOrEmpty(field.DefaultAsString))
        {
            defaultString = field.DefaultAsString;

            if (defaultString.StartsWith("L\""))
            {
                defaultString = defaultString.Substring(1);
            }
        }

        // typescript will default all uninit value to undefined, so here init
        // for non-null type.
        if (string.IsNullOrEmpty(defaultString))
        {
            if (field is String8Field || field is String16Field)
            {
                defaultString = "\"\"";
            }
        }

        return defaultString;
    }

    public static void InitAllTypes(Dictionary<string, TypeBase> allTypes)
    {
        AllTypes = allTypes;
    }

    /// Same as field.Name but resolve the conflict with base properties
    public static string GetFieldName(StructDef structDef, FieldBase field)
    {
        string name = field.Name;
        int conflict = ConflictingBaseProperties(structDef, name);
        if (conflict != 0)
        {
            return String.Format("{0}{1}", name, conflict);
        }
        else
        {
            return name;
        }
    }

    private static int ConflictingBaseProperties(StructDef structDef, string propName)
    {
        if (structDef.HasBase)
        {
            StructDef baseDef = FindBaseDef(structDef);

            return ConflictingClassProperties(baseDef, propName)
                 + ConflictingBaseProperties(baseDef, propName);
        }
        return 0;
    }

    private static int ConflictingClassProperties(StructDef structDef, string propName)
    {
        foreach (FieldBase field in structDef.Items)
        {
            if (field.Name.Equals(propName))
            {
                return 1;
            }
        }

        return 0;
    }

    public static StructDef FindBaseDef(StructDef structDef)
    {
        if (structDef.HasBase)
        {
            string qualifiedName = structDef.BaseType.GetFullNamespaceBond() + "." + structDef.BaseType.Type;
            return AllTypes[qualifiedName] as StructDef;
        }
        else
        {
            return null;
        }
    }
    
    private const string BondTypeConstNamespace = "Microsoft.Bond.BondDataType.";
    private static Dictionary<string, TypeBase> AllTypes;
    private static System.Collections.Generic.Dictionary<Type, string> m_bondTypeConstMap;
    private static int m_uid = 0;
}
#>
<#+
internal class Xml_Class_Begin
    : XidlStructRule
{
    public override void StructBegin(StructDef o)
    {
		string description = ClassBeginUtils.GetValueOfAttributeWithName("Description", o).Replace("\"", "");
		string scenario = ClassBeginUtils.GetValueOfAttributeWithName("Scenario", o).Replace("\"", "");
		PushIndent();
#>
<Event>
	<Name><#=ClassBeginUtils.ConstructStructName(o) #></Name>
	<Description><#=description #></Description>
	<Scenario><#=scenario #></Scenario>
	<Properties>
<#+

    }
}

internal class Xml_Class_Constructor
	: XidlStructRule
{
	public override void StructBegin(StructDef o)
	{

		PushIndent();
		PushIndent();

		StructDef current = o;
		
		// Constructor argument
		while (current != null) 
		{
	        foreach (FieldBase field in current.Items)
			{
				string description = ClassBeginUtils.GetValueOfAttributeWithName("Description", field).Replace("\"", "");
#>
<Property>
	<Name><#=Utils.GetFieldName(current, field)#></Name>
	<Type><#=field.GetFieldType(new CustomIdlTypeMapping())#></Type>
	<Description><#=description #></Description>
</Property>
<#+
			}
			
			if (current.HasBase)
			{
				current = Utils.FindBaseDef(current);
			}
			else
			{
				current = null;
			}
		}

		PopIndent();
		PopIndent();
#>
	</Properties>
<#+
	}
}

public class ClassBeginUtils
{
        public static string ConstructStructName(StructDef structDef)
        {
            string templateArgs = string.Empty;
            if (structDef.TypeParams != null)
            {
                foreach (string templType in structDef.TypeParams)
                {
                    if (templateArgs.Length != 0)
                    {
                        templateArgs += ", ";
                    }
                    templateArgs += templType;
                }
                templateArgs = "<" + templateArgs + ">";
            }
            return structDef.Name + templateArgs;
        }

	public static string ConstructClassName(StructDef structDef) 
	{
		return ClassBeginUtils.ConstructStructName(structDef).Replace(".", "");
	}

	public static string GetValueOfAttributeWithName(string name, XidlBase o)
    {
		CustomAttribute attribute = null;
		for (int i = 0; i < o.UserAttributes.Count && attribute == null; i++)
		{
			CustomAttribute attr = o.UserAttributes[i];
			if (attr.Name == name)
			{
				attribute = attr;
			}
		}

		if (attribute != null)
		{
			return attribute.Value;
		}
		else
		{
			return "";
		}
    }
}
#>
<#+
internal class Xml_Class_End
    : XidlStructRule
{
    public override void StructEnd(StructDef o)
    {
#>
</Event>
<#+
        PopIndent();
    }
}
#>